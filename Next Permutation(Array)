31. Next Permutation

A permutation of an array of integers is an arrangement of its members into a sequence or linear order.
For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].
The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one
container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible,
the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).

For example, the next permutation of arr = [1,2,3] is [1,3,2].
Similarly, the next permutation of arr = [2,3,1] is [3,1,2].
While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.
Given an array of integers nums, find the next permutation of nums.

The replacement must be in place and use only constant extra memory.

Example 1:

Input: nums = [1,2,3]
Output: [1,3,2]
Example 2:

Input: nums = [3,2,1]
Output: [1,2,3]
Example 3:

Input: nums = [1,1,5]
Output: [1,5,1]
 

Constraints:

1 <= nums.length <= 100
0 <= nums[i] <= 100

APPROACH 1: Generate all the permutations and then sort them and then traverse the array of array and find the next permutation .
TC: O(n*n!) 

CODE: 
class Solution {
public:
    // Recursive function to generate all permutations
    vector<vector<int>> res;
    void permutations(map<vector<int>, int>&mp, vector<int>& temp,
                                  vector<int>& visit, vector<int>& nums) {
        if (temp.size() == nums.size()) {
            
            if(mp.find(temp) == mp.end())
            {
…        } 
        else {
            // Otherwise, move to the next permutation
            nums = res[index + 1];
        }
    }
};



APPROACH 2: Traversal 
  1. first start traversing from last and find the first smallest number by comparing 
                     arr[i]<arr[i+1]  index = i;
  2. now again traverse from last and find the just greater number then the index number and swap them 
                   swap(arr[index], arr[i])
  3. reverse the rest of the array from index+1 to last 
                  reverse(arr.begin()+index+1, arr.end())

if not found the index then reverse the whole array. 


TC: O(n)+O(n);


CODE: 

class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        
          int index=-1;
          int n=nums.size();

          for(int i=n-2; i>=0; i--)
          {
             if(nums[i]<nums[i+1])
…
         
           reverse(nums.begin()+index+1, nums.end());
          
          

    }
};
